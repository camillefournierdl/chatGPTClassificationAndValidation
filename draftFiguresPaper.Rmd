---
title: "draftFiguresPaper"
author: "Camille"
date: "2025-05-23"
output: html_document
---

```{r}
library(tidyverse)
"%ni%" = Negate("%in%")

datasetClassification <- read.csv("output/dataClassifToPlot.csv")

datasetCountries <- read.csv("dataNew/allgpt-lit_w_countries.csv")

datasetClassificationCountries <- merge(datasetClassification, datasetCountries %>% 
                                          select(X, Year, country) %>% 
                                          rename(ID = X),
                                        by = "ID") %>% 
  select(-reader)

datasetClassificationCountries$country <- ifelse(datasetClassificationCountries$country == "None", "Unknown", datasetClassificationCountries$country)

table(datasetClassificationCountries$country)

# 1) split into one row per country
datasetClassificationCountries_long <- datasetClassificationCountries %>%
  separate_rows(country, sep = ";\\s*") %>%
  mutate(countries = str_trim(country))

# fix country names 
library(countrycode)

# 1. Direct mapping
datasetClassificationCountries_long_clean <- datasetClassificationCountries_long %>%
  mutate(
    iso3 = countrycode(countries,
                       origin      = "country.name",
                       destination = "iso3c")
  ) %>% 
  filter(countries %ni% c("", " ", "Kosovo", "Southeast Asia"))

### add income groups to the dataset

incomeGroups <- read.csv("dataNew/worldBankIncomeGroups.csv", sep = ";")
incomeGroups$Income.group <- ifelse(incomeGroups$Code == "VEN", "Upper middle income", incomeGroups$Income.group)

datasetClassificationCountries_long_clean <- merge(datasetClassificationCountries_long_clean, incomeGroups, by.x = "iso3", by.y = "Code", all.x = T, all.y = F)

# 2) get total papers by country
papers_by_country <- datasetClassificationCountries_long_clean %>%
  group_by(country, iso3, .drop = F) %>% 
  count(iso3, name = "n_papers") %>%
  arrange(desc(n_papers)) %>% 
  merge(., incomeGroups, by.x = "iso3", by.y = "Code", all.x = T, all.y = F)

papers_by_country$Income.group <- factor(
  papers_by_country$Income.group,
  levels = c(
    "High income",
    "Upper middle income",
    "Lower middle income",
    "Low income"
  ),
  ordered = TRUE
)

pCountryPaperIncome <- papers_by_country %>%
  slice_max(n_papers, n = 20) %>%                     # top 30
  mutate(
    # 1) reorder by paper count (so bars go largest→smallest),
    country = fct_reorder(country, n_papers),
    # 2) then shove "Unknown" to the very end
    country = fct_relevel(country, "Unknown", after = 0)
  ) %>%
  ggplot(aes(x = country, y = n_papers, fill = Income.group)) +
    geom_col() +
    coord_flip() +
    scale_fill_discrete(na.value = 'grey')+
    labs(
      x = "Country",
      y = "Number of papers",
      title = "Top 20 Countries by Paper Count"
    ) +
    theme_minimal()

ggsave(plot = pCountryPaperIncome, filename = paste("plots/countryPapersIncome.png", sep = ""),
       dpi=600, width = 16, height = 12, units='cm')


#### make a map ####

### getting the data together
library(rnaturalearth)
library(terra)
library(tidyterra)

world_countries <- vect(ne_countries(scale = "large", returnclass = "sf"))

world_countries$iso_a3 <- ifelse(world_countries$sovereignt == "Somaliland", "SOM", world_countries$iso_a3)

world_countries_merged <- merge(world_countries, papers_by_country, by.x = "adm0_a3", by.y = "iso3", all.x = T)

world_countries_merged$n_papers <- ifelse(is.na(world_countries_merged$n_papers), 0, world_countries_merged$n_papers)

my_breaks = c(1, 5, 20, 50, 150)

map_plot_reference <- ggplot() +
  geom_spatvector(data = world_countries_merged, aes(fill = n_papers)) +
  scale_fill_gradient(name = "nb of papers", trans = "log",
                        breaks = my_breaks, labels = my_breaks)+
  theme_void()

plot(map_plot_reference)

library(scales)          # for label formatting

# 1) Filter out Antarctica from your data:
world_no_antarctica <- 
  world_countries_merged %>%
  filter(name != "Antarctica")

# 2) Build the map with integer labels and no decimals:
map_plot_viridis_clean <- ggplot() +
  geom_spatvector(
    data = world_no_antarctica,
    aes(fill = n_papers),
    color = "grey70",
    size  = 0.1
  ) +
  scale_fill_viridis_c(
    name    = "Papers",
    # option  = "plasma",
    trans   = "log10",
    breaks  = my_breaks,
    labels  = label_number(accuracy = 1,    # round to whole numbers
                           big.mark = ",",
                           trim     = TRUE),
    na.value = "grey80"
  ) +
  coord_sf(expand = FALSE) +
  labs(
    title    = "Global Publication Counts by Country",
    # subtitle = "Log₁₀ scale, viridis “plasma” palette"
  ) +
  theme_void(base_size = 14) +
  theme(
    legend.position  = "bottom",
    legend.key.width = unit(2, "cm"),
    plot.title       = element_text(face = "bold", hjust = 0.5),
    plot.subtitle    = element_text(hjust = 0.5)
  )

# Print it
map_plot_viridis_clean

ggsave(plot = map_plot_viridis_clean, filename = paste("plots/mapPapersCount.png", sep = ""),
       dpi=600, width = 16, height = 12, units='cm')

### add  monitor data to compare
# load the monitor dataset and subset it
monitors <- read.csv("dataNew/mergedMonitors_v7.csv")

# keep only reference grade monitors
monitorsRef <- subset(monitors, isMonitor)

# keep only active (different datasets have different ways of dealing with that)
# airnow
# no subset because no precise info on when active

# openaq
monitorsRef$diffDays <- as.numeric(difftime(monitorsRef$lastUpdated, monitorsRef$firstUpdated, units = "days"))

monitorsRef <- subset(monitorsRef, !(diffDays < 30 & firstUpdated < ymd_hms("2025-02-01T00:00:00+00:00") & database == "OpenAQ"))

# waqi
monitorsRef <- subset(monitorsRef, !(occurenceWAQI < 2 & database == "WAQI"))

# WHO I am not sure if we should filter points that are only active for a year
table(monitorsRef$database)

# we probably want to check if the results are consistent if removing embassy monitors
table(monitorsRef$isEmbassy)

monitorsRef_simple <- monitorsRef %>%
  # filter(!isEmbassy) %>% # here to filter embassies
  select(newID, longitude, latitude)

monitors_vect <- vect(monitorsRef_simple, geom=c("longitude", "latitude"), crs=crs(world_no_antarctica))

# 1. intersect: this returns only those points lying in (or on) each polygon,
#    with the polygon’s attributes copied over
pts_in_c <- intersect(monitors_vect, world_no_antarctica)

# 2. now simply tally by the country name
counts2 <- table(pts_in_c$iso_a3)

print(counts2)

# aggregate the intersected points by country NAME
agg <- aggregate(pts_in_c, by = "iso_a3", fun = length) %>% as.data.frame() %>% 
  rename(count = agg_newID) %>% 
  select(iso_a3, count)

# join back to the country layer
world_no_antarctica <- merge(world_no_antarctica, agg, by = "iso_a3", all.x = TRUE)

world_no_antarctica_df <- world_no_antarctica %>% as.data.frame()

world_no_antarctica_df$count <- ifelse(is.na(world_no_antarctica_df$count), 0, world_no_antarctica_df$count)

world_no_antarctica_df %>% ggplot(aes(x = n_papers, y = count))+
  geom_point()+
  geom_smooth(method = "lm")+
  facet_wrap(~income_grp)



# world_no_antarctica_df %>% ggplot(aes(x = n_papers, y = count))+
#   geom_point()+
#   geom_smooth(method = "lm")+
#   facet_wrap(~Income.group)

world_no_antarctica_df %>% ggplot(aes(x = n_papers, y = count))+
  geom_point()+
  geom_smooth(method = "lm")

subset(world_no_antarctica_df, count < 10) %>% ggplot(aes(x = n_papers, y = count))+
  geom_point()+
  geom_smooth(method = "lm")

#### vs mean levels of pollution !!! to be done ####



##### categories over time #####
# 

# 2) count papers per country-year
yearly <- datasetClassificationCountries_long_clean %>%
  count(Income.group, Year, name = "n_year") 

# 3) ensure every country has an entry for every year in your span
years <- seq(min(datasetClassificationCountries_long_clean$Year),
             max(datasetClassificationCountries_long_clean$Year))

yearly_complete <- yearly %>%
  complete(Income.group, Year = years, fill = list(n_year = 0))

# 4) compute cumulative sum within each country
cum <- yearly_complete %>%
  group_by(Income.group) %>%
  arrange(Year, .by_group = TRUE) %>%
  mutate(n_cumulative = cumsum(n_year)) %>%
  ungroup()

cum$Income.group <- ifelse(is.na(cum$Income.group), "Unknown", cum$Income.group)

cum$Income.group <- factor(
  cum$Income.group,
  levels = c(
    "High income",
    "Upper middle income",
    "Lower middle income",
    "Low income"
    # "Unknown"
  ),
  ordered = TRUE
)

ppapersIncome <- cum %>%
  ggplot(aes(x = Year, y = n_cumulative, col = Income.group)) +
    geom_line(linewidth = 1) +
    labs(
      x = "Year",
      y = "Cumulative # of Papers",
      title = "Growth of Papers by income group"
    ) +
    theme_minimal()

ggsave(plot = ppapersIncome, filename = paste("plots/incomePaperYear.png", sep = ""),
       dpi=600, width = 16, height = 8, units='cm')

# then cumulative for different categories of papers

# 1) pivot your dummy columns into long form
df_cat_long <- datasetClassificationCountries_long_clean %>%
  pivot_longer(
    cols = c(Perceptions, Priority, Policy, Health, Behavior),
    names_to  = "category",
    values_to = "flag"
  ) %>%
  # keep only “paper belongs to this category”
  filter(flag == 1) %>%
  select(-flag)

# 2) count per year × income_group × category
yearly_cat <- df_cat_long %>%
  count(Year, Income.group, category, name = "n_papers")

# 3) fill zeros so lines don’t break
all_years <- seq(min(datasetClassificationCountries_long_clean$Year), max(datasetClassificationCountries_long_clean$Year))

yearly_cat <- yearly_cat %>%
  complete(
    Year, Income.group, category,
    fill = list(n_papers = 0)
  )

yearly_cat$Income.group <- factor(
  yearly_cat$Income.group,
  levels = c(
    "High income",
    "Upper middle income",
    "Lower middle income",
    "Low income"
    # "Unknown"
  ),
  ordered = TRUE
)

yearly_cat <- yearly_cat %>%
  group_by(Income.group, category) %>%
  arrange(Year, .by_group = TRUE) %>%
  mutate(n_cum = cumsum(n_papers)) %>%
  ungroup() %>% 
  # reorder so levels go from lowest to highest n_cum at the final Year
  mutate(category = fct_reorder2(category, Year, n_cum))

# 4) plot: one facet per category, colored by income group
ppapersIncomeYear <- ggplot(yearly_cat,
       aes(x = Year, y = n_cum, color = category)) +
  geom_line(linewidth = 1) +
  facet_wrap(~ Income.group, scales = "free_y") +
  theme_minimal()

ggsave(plot = ppapersIncomeYear, filename = paste("plots/incomeCategoryPapersYear.png", sep = ""),
       dpi=600, width = 20, height = 12, units='cm')

# a) sum across incomes, then compute cumulative
yearly_cat_agg <- yearly_cat %>%
  group_by(Year, category) %>%
  summarise(n_year = sum(n_papers), .groups="drop") %>%
  arrange(category, Year) %>%
  group_by(category) %>%
  mutate(n_cum = cumsum(n_year)) %>%
  ungroup()

# b) plot one line per category
ppapersYear <- ggplot(yearly_cat_agg,
       aes(x = Year, y = n_cum, color = category)) +
  geom_line(linewidth = 1) +
  theme_minimal() +
  labs(
    x     = "Year",
    y     = "Cumulative # of Papers",
    color = "Category",
    title = "Cumulative Papers by Category (all incomes combined)"
  )

ggsave(plot = ppapersYear, filename = paste("plots/countryPapersYear.png", sep = ""),
       dpi=600, width = 16, height = 8, units='cm')


```



```{r linking nb of papers with pollution levels over space and time?}

```


```{r survey classification}

library(tidyverse)
"%ni%" = Negate("%in%")

surveyClassification <- read.csv("dataNew/surveyClassif.csv", sep = ";")

surveyClassification$surveyedCountries <- ifelse(surveyClassification$surveyedCountries == "Kazakhstan; Kyrgyzstan, Tajikistan, Uzbekistan, Turkmenistan",
                                                 "Kazakhstan; Kyrgyzstan; Tajikistan; Uzbekistan; Turkmenistan",
                                                 surveyClassification$surveyedCountries)

# 1) split into one row per country
surveyCountries_long <- surveyClassification %>%
  separate_rows(surveyedCountries, sep = ";\\s*") %>%
  mutate(countries = str_trim(surveyedCountries))

# fix country names first manual then with iso3

surveyCountries_long$countries <- ifelse(surveyCountries_long$countries %in% c("Phillipines", "Philliphines", "Phillippines"), "Philippines",
                                         ifelse(surveyCountries_long$countries %in% c("Northern Ireland"), "Ireland",
                                                ifelse(surveyCountries_long$countries %in% c("Czech"), "Czechia",
                                                       ifelse(surveyCountries_long$countries %in% c("Uruguah"), "Uruguay",
                                                              ifelse(surveyCountries_long$countries %in% c("Natherlands"), "Netherlands",
                                                                     ifelse(surveyCountries_long$countries %in% c("Croaatia"), "Croatia",
                                                                            ifelse(surveyCountries_long$countries %in% c("Kyrgysztan"), "Kyrgyzstan",
                                                                                   ifelse(surveyCountries_long$countries %in% c("El Savador"), "El Salvador", surveyCountries_long$countries))))))))



library(countrycode)

# 1. Direct mapping
surveyCountries_long_clean <- surveyCountries_long %>%
  mutate(
    iso3 = countrycode(countries,
                       origin      = "country.name",
                       destination = "iso3c")
  ) %>% 
  filter(countries %ni% c("", " ", "Kosovo", "Southeast Asia"))

incomeGroups <- read.csv("dataNew/worldBankIncomeGroups.csv", sep = ";")
incomeGroups$Income.group <- ifelse(incomeGroups$Code == "VEN", "Upper middle income", incomeGroups$Income.group)

surveyCountries_long_clean <- merge(surveyCountries_long_clean, incomeGroups, by.x = "iso3", by.y = "Code", all.x = T, all.y = F)

# 2) get total surveys by country
surveys_by_country <- surveyCountries_long_clean %>%
  group_by(countries, iso3, .drop = F) %>% 
  count(iso3, name = "n_surveys") %>%
  arrange(desc(n_surveys)) %>% 
  merge(., incomeGroups, by.x = "iso3", by.y = "Code", all.x = T, all.y = F)

psurveyCountry <- surveys_by_country %>%
  slice_max(n_surveys, n = 40) %>%                     # top 30
  mutate(
    # 1) reorder by paper count (so bars go largest→smallest),
    country = fct_reorder(countries, n_surveys),
    # 2) then shove "Unknown" to the very end
    # country = fct_relevel(country, "Unknown", after = 0)
  ) %>%
  ggplot(aes(x = country, y = n_surveys, fill = Income.group)) +
    geom_col() +
    coord_flip() +
    scale_fill_discrete(na.value = 'grey')+
    labs(
      x = "Country",
      y = "Number of Surveys",
      title = "Top 40 Countries by Survey Question Count"
    ) +
    theme_minimal()

ggsave(plot = psurveyCountry, filename = paste("plots/countrySurveyIncome.png", sep = ""),
       dpi=600, width = 16, height = 12, units='cm')

df_cat_long <- surveyCountries_long_clean %>%
  pivot_longer(
    cols = c(Perceptions, Priority, Policy, Health, Behavior),
    names_to  = "category",
    values_to = "flag"
  ) %>%
  # keep only “paper belongs to this category”
  filter(flag == 1) %>%
  select(-flag)

# 2) count per year × income_group × category
overall_cat <- df_cat_long %>%
  count(Income.group, category, name = "n_surveys")

# 4) plot: one facet per category, colored by income group
ggplot(overall_cat,
       aes(y = n_surveys, x = category, fill = category)) +
  geom_col() +
  facet_wrap(~ Income.group, scales = "free_y") +
  theme_minimal()



## same but over time 


surveyCountries_long_clean_yearly <- surveyCountries_long_clean
surveyCountries_long_clean_yearly$year <- ifelse(surveyCountries_long_clean_yearly$year == "2017 - 2021", 2018, surveyCountries_long_clean_yearly$year)
surveyCountries_long_clean_yearly$year <- ifelse(surveyCountries_long_clean_yearly$year == "2021 - 2022", 2021, surveyCountries_long_clean_yearly$year)

surveyCountries_long_clean_yearly_t <- surveyCountries_long_clean_yearly %>%
  # 1. build a single “years” string
  mutate(
    all_years = if_else(
      is.na(repeatedMeasure) | repeatedMeasure == "",
      as.character(year),
      paste(year, repeatedMeasure, sep = ";")
    ),
    # drop every space character
    all_years = str_remove_all(all_years, "\\s+")
  ) %>%
  separate_rows(all_years, sep = ";") %>%
  mutate(year_num = as.integer(all_years)) %>%
  select(-all_years, -repeatedMeasure)

df_cat_long <- surveyCountries_long_clean_yearly_t %>%
  pivot_longer(
    cols = c(Perceptions, Priority, Policy, Health, Behavior),
    names_to  = "category",
    values_to = "flag"
  ) %>%
  # keep only “paper belongs to this category”
  filter(flag == 1) %>%
  select(-flag)

# 2) count per year × income_group × category
yearly_cat <- df_cat_long %>%
  count(year_num, Income.group, category, name = "n_surveys")

# 3) fill zeros so lines don’t break
all_years <- seq(min(surveyCountries_long_clean_yearly_t$year_num), max(surveyCountries_long_clean_yearly_t$year_num))

yearly_cat_filled <- yearly_cat %>%
  complete(
    year_num = all_years,
    Income.group, category,
    fill = list(n_surveys = 0)
  )

yearly_cat_filled <- yearly_cat_filled %>%
  group_by(Income.group, category) %>%
  arrange(year_num, .by_group = TRUE) %>%
  mutate(n_cum = cumsum(n_surveys)) %>%
  ungroup() %>% 
  # reorder so levels go from lowest to highest n_cum at the final Year
  mutate(category = fct_reorder2(category, year_num, n_cum))

# 4) plot: one facet per income group, colored by category
ggplot(yearly_cat_filled,
       aes(x = year_num, y = n_cum, color = category)) +
  # geom_point()+
  geom_line(linewidth = 2) +
  facet_wrap(~ Income.group, scales = "free_y") +
  theme_minimal()

yearly_cat_filled$Income.group <- factor(
  yearly_cat_filled$Income.group,
  levels = c(
    "High income",
    "Upper middle income",
    "Lower middle income",
    "Low income"
  ),
  ordered = TRUE
)

pyear_survey <- ggplot(yearly_cat_filled,
       aes(x = year_num, y = n_cum, color = category)) +
  # geom_point()+
  geom_line(linewidth = 1) +
  facet_wrap(~ Income.group, scales = "free_y") +
  theme_minimal()

ggsave(plot = pyear_survey, filename = paste("plots/yearSurveyIncome.png", sep = ""),
       dpi=600, width = 16, height = 8, units='cm')

```



```{r make a map for the survey data}

#### make a map ####

### getting the data together
library(rnaturalearth)
library(terra)
library(tidyterra)
library(tidyverse)

"%ni%" = Negate("%in%")

surveyClassification <- read.csv("dataNew/surveyClassif.csv", sep = ";")

surveyClassification$surveyedCountries <- ifelse(surveyClassification$surveyedCountries == "Kazakhstan; Kyrgyzstan, Tajikistan, Uzbekistan, Turkmenistan",
                                                 "Kazakhstan; Kyrgyzstan; Tajikistan; Uzbekistan; Turkmenistan",
                                                 surveyClassification$surveyedCountries)

# 1) split into one row per country
surveyCountries_long <- surveyClassification %>%
  separate_rows(surveyedCountries, sep = ";\\s*") %>%
  mutate(countries = str_trim(surveyedCountries))

# fix country names first manual then with iso3

surveyCountries_long$countries <- ifelse(surveyCountries_long$countries %in% c("Phillipines", "Philliphines", "Phillippines"), "Philippines",
                                         ifelse(surveyCountries_long$countries %in% c("Northern Ireland"), "Ireland",
                                                ifelse(surveyCountries_long$countries %in% c("Czech"), "Czechia",
                                                       ifelse(surveyCountries_long$countries %in% c("Uruguah"), "Uruguay",
                                                              ifelse(surveyCountries_long$countries %in% c("Natherlands"), "Netherlands",
                                                                     ifelse(surveyCountries_long$countries %in% c("Croaatia"), "Croatia",
                                                                            ifelse(surveyCountries_long$countries %in% c("Kyrgysztan"), "Kyrgyzstan",
                                                                                   ifelse(surveyCountries_long$countries %in% c("El Savador"), "El Salvador", surveyCountries_long$countries))))))))



library(countrycode)

# 1. Direct mapping
surveyCountries_long_clean <- surveyCountries_long %>%
  mutate(
    iso3 = countrycode(countries,
                       origin      = "country.name",
                       destination = "iso3c")
  ) %>% 
  filter(countries %ni% c("", " ", "Kosovo", "Southeast Asia"))

incomeGroups <- read.csv("dataNew/worldBankIncomeGroups.csv", sep = ";")
incomeGroups$Income.group <- ifelse(incomeGroups$Code == "VEN", "Upper middle income", incomeGroups$Income.group)

surveyCountries_long_clean <- merge(surveyCountries_long_clean, incomeGroups, by.x = "iso3", by.y = "Code", all.x = T, all.y = F)

# 2) get total surveys by country
surveys_by_country <- surveyCountries_long_clean %>%
  group_by(countries, iso3, .drop = F) %>% 
  count(iso3, name = "n_surveys") %>%
  arrange(desc(n_surveys)) %>% 
  merge(., incomeGroups, by.x = "iso3", by.y = "Code", all.x = T, all.y = F)

world_countries <- vect(ne_countries(scale = "large", returnclass = "sf"))

world_countries$iso_a3 <- ifelse(world_countries$sovereignt == "Somaliland", "SOM", world_countries$iso_a3)

world_countries_merged <- merge(world_countries, surveys_by_country, by.x = "adm0_a3", by.y = "iso3", all.x = T)

world_countries_merged$n_surveys <- ifelse(is.na(world_countries_merged$n_surveys), 0, world_countries_merged$n_surveys)

my_breaks = c(1, 5, 10, 20)

map_plot_reference <- ggplot() +
  geom_spatvector(data = world_countries_merged, aes(fill = n_surveys)) +
  scale_fill_gradient(name = "nb of surveys", trans = "log",
                        breaks = my_breaks, labels = my_breaks)+
  theme_void()

plot(map_plot_reference)

library(scales)          # for label formatting

# 1) Filter out Antarctica from your data:
world_no_antarctica <- 
  world_countries_merged %>%
  filter(name != "Antarctica")

# 2) Build the map with integer labels and no decimals:
map_plot_viridis_clean_survey <- ggplot() +
  geom_spatvector(
    data = world_no_antarctica,
    aes(fill = n_surveys),
    color = "grey70",
    size  = 0.1
  ) +
  scale_fill_viridis_c(
    name    = "Papers",
    # option  = "plasma",
    trans   = "log10",
    breaks  = my_breaks,
    labels  = label_number(accuracy = 1,    # round to whole numbers
                           big.mark = ",",
                           trim     = TRUE),
    na.value = "grey80"
  ) +
  coord_sf(expand = FALSE) +
  labs(
    title    = "Global Survey Question Counts by Country",
    # subtitle = "Log₁₀ scale, viridis “plasma” palette"
  ) +
  theme_void(base_size = 14) +
  theme(
    legend.position  = "bottom",
    legend.key.width = unit(2, "cm"),
    plot.title       = element_text(face = "bold", hjust = 0.5),
    plot.subtitle    = element_text(hjust = 0.5)
  )

# Print it
map_plot_viridis_clean_survey

ggsave(plot = map_plot_viridis_clean_survey, filename = paste("plots/mapSurveyCount.png", sep = ""),
       dpi=600, width = 16, height = 12, units='cm')




```







